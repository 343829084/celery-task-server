#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def encrypt(self, str):
        """
        Parameters:
         - str
        """
        pass

    def decrypt(self, str):
        """
        Parameters:
         - str
        """
        pass

    def batchEncrypt(self, vec):
        """
        Parameters:
         - vec
        """
        pass

    def batchDecrypt(self, vec):
        """
        Parameters:
         - vec
        """
        pass

    def batchEncryptWithFlag(self, flag, vec):
        """
        Parameters:
         - flag
         - vec
        """
        pass

    def batchDecryptWithFlag(self, flag, vec):
        """
        Parameters:
         - flag
         - vec
        """
        pass

    def encryptAndBase64(self, str):
        """
        Parameters:
         - str
        """
        pass

    def decryptAndBase64(self, str):
        """
        Parameters:
         - str
        """
        pass

    def batchEncryptAndBase64(self, vec):
        """
        Parameters:
         - vec
        """
        pass

    def batchDecryptAndBase64(self, vec):
        """
        Parameters:
         - vec
        """
        pass

    def batchEncryptWithFlagAndBase64(self, flag, vec):
        """
        Parameters:
         - flag
         - vec
        """
        pass

    def batchDecryptWithFlagAndBase64(self, flag, vec):
        """
        Parameters:
         - flag
         - vec
        """
        pass

    def encryptUseEcbModel(self, str):
        """
        Parameters:
         - str
        """
        pass

    def decryptUseEcbModel(self, str):
        """
        Parameters:
         - str
        """
        pass

    def batchEncryptUseEcbModel(self, vec):
        """
        Parameters:
         - vec
        """
        pass

    def batchDecryptUseEcbModel(self, vec):
        """
        Parameters:
         - vec
        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def encrypt(self, str):
        """
        Parameters:
         - str
        """
        self.send_encrypt(str)
        return self.recv_encrypt()

    def send_encrypt(self, str):
        self._oprot.writeMessageBegin('encrypt', TMessageType.CALL, self._seqid)
        args = encrypt_args()
        args.str = str
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_encrypt(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = encrypt_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "encrypt failed: unknown result")

    def decrypt(self, str):
        """
        Parameters:
         - str
        """
        self.send_decrypt(str)
        return self.recv_decrypt()

    def send_decrypt(self, str):
        self._oprot.writeMessageBegin('decrypt', TMessageType.CALL, self._seqid)
        args = decrypt_args()
        args.str = str
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_decrypt(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = decrypt_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "decrypt failed: unknown result")

    def batchEncrypt(self, vec):
        """
        Parameters:
         - vec
        """
        self.send_batchEncrypt(vec)
        return self.recv_batchEncrypt()

    def send_batchEncrypt(self, vec):
        self._oprot.writeMessageBegin('batchEncrypt', TMessageType.CALL, self._seqid)
        args = batchEncrypt_args()
        args.vec = vec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_batchEncrypt(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = batchEncrypt_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "batchEncrypt failed: unknown result")

    def batchDecrypt(self, vec):
        """
        Parameters:
         - vec
        """
        self.send_batchDecrypt(vec)
        return self.recv_batchDecrypt()

    def send_batchDecrypt(self, vec):
        self._oprot.writeMessageBegin('batchDecrypt', TMessageType.CALL, self._seqid)
        args = batchDecrypt_args()
        args.vec = vec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_batchDecrypt(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = batchDecrypt_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "batchDecrypt failed: unknown result")

    def batchEncryptWithFlag(self, flag, vec):
        """
        Parameters:
         - flag
         - vec
        """
        self.send_batchEncryptWithFlag(flag, vec)
        return self.recv_batchEncryptWithFlag()

    def send_batchEncryptWithFlag(self, flag, vec):
        self._oprot.writeMessageBegin('batchEncryptWithFlag', TMessageType.CALL, self._seqid)
        args = batchEncryptWithFlag_args()
        args.flag = flag
        args.vec = vec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_batchEncryptWithFlag(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = batchEncryptWithFlag_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "batchEncryptWithFlag failed: unknown result")

    def batchDecryptWithFlag(self, flag, vec):
        """
        Parameters:
         - flag
         - vec
        """
        self.send_batchDecryptWithFlag(flag, vec)
        return self.recv_batchDecryptWithFlag()

    def send_batchDecryptWithFlag(self, flag, vec):
        self._oprot.writeMessageBegin('batchDecryptWithFlag', TMessageType.CALL, self._seqid)
        args = batchDecryptWithFlag_args()
        args.flag = flag
        args.vec = vec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_batchDecryptWithFlag(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = batchDecryptWithFlag_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "batchDecryptWithFlag failed: unknown result")

    def encryptAndBase64(self, str):
        """
        Parameters:
         - str
        """
        self.send_encryptAndBase64(str)
        return self.recv_encryptAndBase64()

    def send_encryptAndBase64(self, str):
        self._oprot.writeMessageBegin('encryptAndBase64', TMessageType.CALL, self._seqid)
        args = encryptAndBase64_args()
        args.str = str
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_encryptAndBase64(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = encryptAndBase64_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "encryptAndBase64 failed: unknown result")

    def decryptAndBase64(self, str):
        """
        Parameters:
         - str
        """
        self.send_decryptAndBase64(str)
        return self.recv_decryptAndBase64()

    def send_decryptAndBase64(self, str):
        self._oprot.writeMessageBegin('decryptAndBase64', TMessageType.CALL, self._seqid)
        args = decryptAndBase64_args()
        args.str = str
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_decryptAndBase64(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = decryptAndBase64_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "decryptAndBase64 failed: unknown result")

    def batchEncryptAndBase64(self, vec):
        """
        Parameters:
         - vec
        """
        self.send_batchEncryptAndBase64(vec)
        return self.recv_batchEncryptAndBase64()

    def send_batchEncryptAndBase64(self, vec):
        self._oprot.writeMessageBegin('batchEncryptAndBase64', TMessageType.CALL, self._seqid)
        args = batchEncryptAndBase64_args()
        args.vec = vec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_batchEncryptAndBase64(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = batchEncryptAndBase64_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "batchEncryptAndBase64 failed: unknown result")

    def batchDecryptAndBase64(self, vec):
        """
        Parameters:
         - vec
        """
        self.send_batchDecryptAndBase64(vec)
        return self.recv_batchDecryptAndBase64()

    def send_batchDecryptAndBase64(self, vec):
        self._oprot.writeMessageBegin('batchDecryptAndBase64', TMessageType.CALL, self._seqid)
        args = batchDecryptAndBase64_args()
        args.vec = vec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_batchDecryptAndBase64(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = batchDecryptAndBase64_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "batchDecryptAndBase64 failed: unknown result")

    def batchEncryptWithFlagAndBase64(self, flag, vec):
        """
        Parameters:
         - flag
         - vec
        """
        self.send_batchEncryptWithFlagAndBase64(flag, vec)
        return self.recv_batchEncryptWithFlagAndBase64()

    def send_batchEncryptWithFlagAndBase64(self, flag, vec):
        self._oprot.writeMessageBegin('batchEncryptWithFlagAndBase64', TMessageType.CALL, self._seqid)
        args = batchEncryptWithFlagAndBase64_args()
        args.flag = flag
        args.vec = vec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_batchEncryptWithFlagAndBase64(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = batchEncryptWithFlagAndBase64_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "batchEncryptWithFlagAndBase64 failed: unknown result")

    def batchDecryptWithFlagAndBase64(self, flag, vec):
        """
        Parameters:
         - flag
         - vec
        """
        self.send_batchDecryptWithFlagAndBase64(flag, vec)
        return self.recv_batchDecryptWithFlagAndBase64()

    def send_batchDecryptWithFlagAndBase64(self, flag, vec):
        self._oprot.writeMessageBegin('batchDecryptWithFlagAndBase64', TMessageType.CALL, self._seqid)
        args = batchDecryptWithFlagAndBase64_args()
        args.flag = flag
        args.vec = vec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_batchDecryptWithFlagAndBase64(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = batchDecryptWithFlagAndBase64_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "batchDecryptWithFlagAndBase64 failed: unknown result")

    def encryptUseEcbModel(self, str):
        """
        Parameters:
         - str
        """
        self.send_encryptUseEcbModel(str)
        return self.recv_encryptUseEcbModel()

    def send_encryptUseEcbModel(self, str):
        self._oprot.writeMessageBegin('encryptUseEcbModel', TMessageType.CALL, self._seqid)
        args = encryptUseEcbModel_args()
        args.str = str
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_encryptUseEcbModel(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = encryptUseEcbModel_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "encryptUseEcbModel failed: unknown result")

    def decryptUseEcbModel(self, str):
        """
        Parameters:
         - str
        """
        self.send_decryptUseEcbModel(str)
        return self.recv_decryptUseEcbModel()

    def send_decryptUseEcbModel(self, str):
        self._oprot.writeMessageBegin('decryptUseEcbModel', TMessageType.CALL, self._seqid)
        args = decryptUseEcbModel_args()
        args.str = str
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_decryptUseEcbModel(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = decryptUseEcbModel_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "decryptUseEcbModel failed: unknown result")

    def batchEncryptUseEcbModel(self, vec):
        """
        Parameters:
         - vec
        """
        self.send_batchEncryptUseEcbModel(vec)
        return self.recv_batchEncryptUseEcbModel()

    def send_batchEncryptUseEcbModel(self, vec):
        self._oprot.writeMessageBegin('batchEncryptUseEcbModel', TMessageType.CALL, self._seqid)
        args = batchEncryptUseEcbModel_args()
        args.vec = vec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_batchEncryptUseEcbModel(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = batchEncryptUseEcbModel_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "batchEncryptUseEcbModel failed: unknown result")

    def batchDecryptUseEcbModel(self, vec):
        """
        Parameters:
         - vec
        """
        self.send_batchDecryptUseEcbModel(vec)
        return self.recv_batchDecryptUseEcbModel()

    def send_batchDecryptUseEcbModel(self, vec):
        self._oprot.writeMessageBegin('batchDecryptUseEcbModel', TMessageType.CALL, self._seqid)
        args = batchDecryptUseEcbModel_args()
        args.vec = vec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_batchDecryptUseEcbModel(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = batchDecryptUseEcbModel_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "batchDecryptUseEcbModel failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["encrypt"] = Processor.process_encrypt
        self._processMap["decrypt"] = Processor.process_decrypt
        self._processMap["batchEncrypt"] = Processor.process_batchEncrypt
        self._processMap["batchDecrypt"] = Processor.process_batchDecrypt
        self._processMap["batchEncryptWithFlag"] = Processor.process_batchEncryptWithFlag
        self._processMap["batchDecryptWithFlag"] = Processor.process_batchDecryptWithFlag
        self._processMap["encryptAndBase64"] = Processor.process_encryptAndBase64
        self._processMap["decryptAndBase64"] = Processor.process_decryptAndBase64
        self._processMap["batchEncryptAndBase64"] = Processor.process_batchEncryptAndBase64
        self._processMap["batchDecryptAndBase64"] = Processor.process_batchDecryptAndBase64
        self._processMap["batchEncryptWithFlagAndBase64"] = Processor.process_batchEncryptWithFlagAndBase64
        self._processMap["batchDecryptWithFlagAndBase64"] = Processor.process_batchDecryptWithFlagAndBase64
        self._processMap["encryptUseEcbModel"] = Processor.process_encryptUseEcbModel
        self._processMap["decryptUseEcbModel"] = Processor.process_decryptUseEcbModel
        self._processMap["batchEncryptUseEcbModel"] = Processor.process_batchEncryptUseEcbModel
        self._processMap["batchDecryptUseEcbModel"] = Processor.process_batchDecryptUseEcbModel

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_encrypt(self, seqid, iprot, oprot):
        args = encrypt_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = encrypt_result()
        try:
            result.success = self._handler.encrypt(args.str)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("encrypt", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_decrypt(self, seqid, iprot, oprot):
        args = decrypt_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = decrypt_result()
        try:
            result.success = self._handler.decrypt(args.str)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("decrypt", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_batchEncrypt(self, seqid, iprot, oprot):
        args = batchEncrypt_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = batchEncrypt_result()
        try:
            result.success = self._handler.batchEncrypt(args.vec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("batchEncrypt", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_batchDecrypt(self, seqid, iprot, oprot):
        args = batchDecrypt_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = batchDecrypt_result()
        try:
            result.success = self._handler.batchDecrypt(args.vec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("batchDecrypt", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_batchEncryptWithFlag(self, seqid, iprot, oprot):
        args = batchEncryptWithFlag_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = batchEncryptWithFlag_result()
        try:
            result.success = self._handler.batchEncryptWithFlag(args.flag, args.vec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("batchEncryptWithFlag", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_batchDecryptWithFlag(self, seqid, iprot, oprot):
        args = batchDecryptWithFlag_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = batchDecryptWithFlag_result()
        try:
            result.success = self._handler.batchDecryptWithFlag(args.flag, args.vec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("batchDecryptWithFlag", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_encryptAndBase64(self, seqid, iprot, oprot):
        args = encryptAndBase64_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = encryptAndBase64_result()
        try:
            result.success = self._handler.encryptAndBase64(args.str)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("encryptAndBase64", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_decryptAndBase64(self, seqid, iprot, oprot):
        args = decryptAndBase64_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = decryptAndBase64_result()
        try:
            result.success = self._handler.decryptAndBase64(args.str)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("decryptAndBase64", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_batchEncryptAndBase64(self, seqid, iprot, oprot):
        args = batchEncryptAndBase64_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = batchEncryptAndBase64_result()
        try:
            result.success = self._handler.batchEncryptAndBase64(args.vec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("batchEncryptAndBase64", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_batchDecryptAndBase64(self, seqid, iprot, oprot):
        args = batchDecryptAndBase64_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = batchDecryptAndBase64_result()
        try:
            result.success = self._handler.batchDecryptAndBase64(args.vec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("batchDecryptAndBase64", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_batchEncryptWithFlagAndBase64(self, seqid, iprot, oprot):
        args = batchEncryptWithFlagAndBase64_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = batchEncryptWithFlagAndBase64_result()
        try:
            result.success = self._handler.batchEncryptWithFlagAndBase64(args.flag, args.vec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("batchEncryptWithFlagAndBase64", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_batchDecryptWithFlagAndBase64(self, seqid, iprot, oprot):
        args = batchDecryptWithFlagAndBase64_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = batchDecryptWithFlagAndBase64_result()
        try:
            result.success = self._handler.batchDecryptWithFlagAndBase64(args.flag, args.vec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("batchDecryptWithFlagAndBase64", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_encryptUseEcbModel(self, seqid, iprot, oprot):
        args = encryptUseEcbModel_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = encryptUseEcbModel_result()
        try:
            result.success = self._handler.encryptUseEcbModel(args.str)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("encryptUseEcbModel", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_decryptUseEcbModel(self, seqid, iprot, oprot):
        args = decryptUseEcbModel_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = decryptUseEcbModel_result()
        try:
            result.success = self._handler.decryptUseEcbModel(args.str)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("decryptUseEcbModel", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_batchEncryptUseEcbModel(self, seqid, iprot, oprot):
        args = batchEncryptUseEcbModel_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = batchEncryptUseEcbModel_result()
        try:
            result.success = self._handler.batchEncryptUseEcbModel(args.vec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("batchEncryptUseEcbModel", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_batchDecryptUseEcbModel(self, seqid, iprot, oprot):
        args = batchDecryptUseEcbModel_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = batchDecryptUseEcbModel_result()
        try:
            result.success = self._handler.batchDecryptUseEcbModel(args.vec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("batchDecryptUseEcbModel", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class encrypt_args(object):
    """
    Attributes:
     - str
    """


    def __init__(self, str=None,):
        self.str = str

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.str = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('encrypt_args')
        if self.str is not None:
            oprot.writeFieldBegin('str', TType.STRING, 1)
            oprot.writeString(self.str.encode('utf-8') if sys.version_info[0] == 2 else self.str)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(encrypt_args)
encrypt_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'str', 'UTF8', None, ),  # 1
)


class encrypt_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ResultStruct()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('encrypt_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(encrypt_result)
encrypt_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ResultStruct, None], None, ),  # 0
)


class decrypt_args(object):
    """
    Attributes:
     - str
    """


    def __init__(self, str=None,):
        self.str = str

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.str = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('decrypt_args')
        if self.str is not None:
            oprot.writeFieldBegin('str', TType.STRING, 1)
            oprot.writeString(self.str.encode('utf-8') if sys.version_info[0] == 2 else self.str)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(decrypt_args)
decrypt_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'str', 'UTF8', None, ),  # 1
)


class decrypt_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ResultStruct()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('decrypt_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(decrypt_result)
decrypt_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ResultStruct, None], None, ),  # 0
)


class batchEncrypt_args(object):
    """
    Attributes:
     - vec
    """


    def __init__(self, vec=None,):
        self.vec = vec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.vec = {}
                    (_ktype10, _vtype11, _size9) = iprot.readMapBegin()
                    for _i13 in range(_size9):
                        _key14 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val15 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.vec[_key14] = _val15
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('batchEncrypt_args')
        if self.vec is not None:
            oprot.writeFieldBegin('vec', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.vec))
            for kiter16, viter17 in self.vec.items():
                oprot.writeString(kiter16.encode('utf-8') if sys.version_info[0] == 2 else kiter16)
                oprot.writeString(viter17.encode('utf-8') if sys.version_info[0] == 2 else viter17)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(batchEncrypt_args)
batchEncrypt_args.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'vec', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 1
)


class batchEncrypt_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype19, _vtype20, _size18) = iprot.readMapBegin()
                    for _i22 in range(_size18):
                        _key23 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val24 = ResultStruct()
                        _val24.read(iprot)
                        self.success[_key23] = _val24
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('batchEncrypt_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
            for kiter25, viter26 in self.success.items():
                oprot.writeString(kiter25.encode('utf-8') if sys.version_info[0] == 2 else kiter25)
                viter26.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(batchEncrypt_result)
batchEncrypt_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRUCT, [ResultStruct, None], False), None, ),  # 0
)


class batchDecrypt_args(object):
    """
    Attributes:
     - vec
    """


    def __init__(self, vec=None,):
        self.vec = vec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.vec = {}
                    (_ktype28, _vtype29, _size27) = iprot.readMapBegin()
                    for _i31 in range(_size27):
                        _key32 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val33 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.vec[_key32] = _val33
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('batchDecrypt_args')
        if self.vec is not None:
            oprot.writeFieldBegin('vec', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.vec))
            for kiter34, viter35 in self.vec.items():
                oprot.writeString(kiter34.encode('utf-8') if sys.version_info[0] == 2 else kiter34)
                oprot.writeString(viter35.encode('utf-8') if sys.version_info[0] == 2 else viter35)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(batchDecrypt_args)
batchDecrypt_args.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'vec', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 1
)


class batchDecrypt_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype37, _vtype38, _size36) = iprot.readMapBegin()
                    for _i40 in range(_size36):
                        _key41 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val42 = ResultStruct()
                        _val42.read(iprot)
                        self.success[_key41] = _val42
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('batchDecrypt_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
            for kiter43, viter44 in self.success.items():
                oprot.writeString(kiter43.encode('utf-8') if sys.version_info[0] == 2 else kiter43)
                viter44.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(batchDecrypt_result)
batchDecrypt_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRUCT, [ResultStruct, None], False), None, ),  # 0
)


class batchEncryptWithFlag_args(object):
    """
    Attributes:
     - flag
     - vec
    """


    def __init__(self, flag=None, vec=None,):
        self.flag = flag
        self.vec = vec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.flag = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.vec = {}
                    (_ktype46, _vtype47, _size45) = iprot.readMapBegin()
                    for _i49 in range(_size45):
                        _key50 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val51 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.vec[_key50] = _val51
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('batchEncryptWithFlag_args')
        if self.flag is not None:
            oprot.writeFieldBegin('flag', TType.STRING, 1)
            oprot.writeString(self.flag.encode('utf-8') if sys.version_info[0] == 2 else self.flag)
            oprot.writeFieldEnd()
        if self.vec is not None:
            oprot.writeFieldBegin('vec', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.vec))
            for kiter52, viter53 in self.vec.items():
                oprot.writeString(kiter52.encode('utf-8') if sys.version_info[0] == 2 else kiter52)
                oprot.writeString(viter53.encode('utf-8') if sys.version_info[0] == 2 else viter53)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(batchEncryptWithFlag_args)
batchEncryptWithFlag_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'flag', 'UTF8', None, ),  # 1
    (2, TType.MAP, 'vec', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 2
)


class batchEncryptWithFlag_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ResultListWithFlag()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('batchEncryptWithFlag_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(batchEncryptWithFlag_result)
batchEncryptWithFlag_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ResultListWithFlag, None], None, ),  # 0
)


class batchDecryptWithFlag_args(object):
    """
    Attributes:
     - flag
     - vec
    """


    def __init__(self, flag=None, vec=None,):
        self.flag = flag
        self.vec = vec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.flag = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.vec = {}
                    (_ktype55, _vtype56, _size54) = iprot.readMapBegin()
                    for _i58 in range(_size54):
                        _key59 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val60 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.vec[_key59] = _val60
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('batchDecryptWithFlag_args')
        if self.flag is not None:
            oprot.writeFieldBegin('flag', TType.STRING, 1)
            oprot.writeString(self.flag.encode('utf-8') if sys.version_info[0] == 2 else self.flag)
            oprot.writeFieldEnd()
        if self.vec is not None:
            oprot.writeFieldBegin('vec', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.vec))
            for kiter61, viter62 in self.vec.items():
                oprot.writeString(kiter61.encode('utf-8') if sys.version_info[0] == 2 else kiter61)
                oprot.writeString(viter62.encode('utf-8') if sys.version_info[0] == 2 else viter62)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(batchDecryptWithFlag_args)
batchDecryptWithFlag_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'flag', 'UTF8', None, ),  # 1
    (2, TType.MAP, 'vec', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 2
)


class batchDecryptWithFlag_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ResultListWithFlag()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('batchDecryptWithFlag_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(batchDecryptWithFlag_result)
batchDecryptWithFlag_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ResultListWithFlag, None], None, ),  # 0
)


class encryptAndBase64_args(object):
    """
    Attributes:
     - str
    """


    def __init__(self, str=None,):
        self.str = str

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.str = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('encryptAndBase64_args')
        if self.str is not None:
            oprot.writeFieldBegin('str', TType.STRING, 1)
            oprot.writeString(self.str.encode('utf-8') if sys.version_info[0] == 2 else self.str)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(encryptAndBase64_args)
encryptAndBase64_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'str', 'UTF8', None, ),  # 1
)


class encryptAndBase64_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ResultStruct()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('encryptAndBase64_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(encryptAndBase64_result)
encryptAndBase64_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ResultStruct, None], None, ),  # 0
)


class decryptAndBase64_args(object):
    """
    Attributes:
     - str
    """


    def __init__(self, str=None,):
        self.str = str

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.str = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('decryptAndBase64_args')
        if self.str is not None:
            oprot.writeFieldBegin('str', TType.STRING, 1)
            oprot.writeString(self.str.encode('utf-8') if sys.version_info[0] == 2 else self.str)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(decryptAndBase64_args)
decryptAndBase64_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'str', 'UTF8', None, ),  # 1
)


class decryptAndBase64_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ResultStruct()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('decryptAndBase64_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(decryptAndBase64_result)
decryptAndBase64_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ResultStruct, None], None, ),  # 0
)


class batchEncryptAndBase64_args(object):
    """
    Attributes:
     - vec
    """


    def __init__(self, vec=None,):
        self.vec = vec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.vec = {}
                    (_ktype64, _vtype65, _size63) = iprot.readMapBegin()
                    for _i67 in range(_size63):
                        _key68 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val69 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.vec[_key68] = _val69
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('batchEncryptAndBase64_args')
        if self.vec is not None:
            oprot.writeFieldBegin('vec', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.vec))
            for kiter70, viter71 in self.vec.items():
                oprot.writeString(kiter70.encode('utf-8') if sys.version_info[0] == 2 else kiter70)
                oprot.writeString(viter71.encode('utf-8') if sys.version_info[0] == 2 else viter71)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(batchEncryptAndBase64_args)
batchEncryptAndBase64_args.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'vec', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 1
)


class batchEncryptAndBase64_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype73, _vtype74, _size72) = iprot.readMapBegin()
                    for _i76 in range(_size72):
                        _key77 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val78 = ResultStruct()
                        _val78.read(iprot)
                        self.success[_key77] = _val78
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('batchEncryptAndBase64_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
            for kiter79, viter80 in self.success.items():
                oprot.writeString(kiter79.encode('utf-8') if sys.version_info[0] == 2 else kiter79)
                viter80.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(batchEncryptAndBase64_result)
batchEncryptAndBase64_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRUCT, [ResultStruct, None], False), None, ),  # 0
)


class batchDecryptAndBase64_args(object):
    """
    Attributes:
     - vec
    """


    def __init__(self, vec=None,):
        self.vec = vec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.vec = {}
                    (_ktype82, _vtype83, _size81) = iprot.readMapBegin()
                    for _i85 in range(_size81):
                        _key86 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val87 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.vec[_key86] = _val87
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('batchDecryptAndBase64_args')
        if self.vec is not None:
            oprot.writeFieldBegin('vec', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.vec))
            for kiter88, viter89 in self.vec.items():
                oprot.writeString(kiter88.encode('utf-8') if sys.version_info[0] == 2 else kiter88)
                oprot.writeString(viter89.encode('utf-8') if sys.version_info[0] == 2 else viter89)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(batchDecryptAndBase64_args)
batchDecryptAndBase64_args.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'vec', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 1
)


class batchDecryptAndBase64_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype91, _vtype92, _size90) = iprot.readMapBegin()
                    for _i94 in range(_size90):
                        _key95 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val96 = ResultStruct()
                        _val96.read(iprot)
                        self.success[_key95] = _val96
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('batchDecryptAndBase64_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
            for kiter97, viter98 in self.success.items():
                oprot.writeString(kiter97.encode('utf-8') if sys.version_info[0] == 2 else kiter97)
                viter98.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(batchDecryptAndBase64_result)
batchDecryptAndBase64_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRUCT, [ResultStruct, None], False), None, ),  # 0
)


class batchEncryptWithFlagAndBase64_args(object):
    """
    Attributes:
     - flag
     - vec
    """


    def __init__(self, flag=None, vec=None,):
        self.flag = flag
        self.vec = vec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.flag = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.vec = {}
                    (_ktype100, _vtype101, _size99) = iprot.readMapBegin()
                    for _i103 in range(_size99):
                        _key104 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val105 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.vec[_key104] = _val105
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('batchEncryptWithFlagAndBase64_args')
        if self.flag is not None:
            oprot.writeFieldBegin('flag', TType.STRING, 1)
            oprot.writeString(self.flag.encode('utf-8') if sys.version_info[0] == 2 else self.flag)
            oprot.writeFieldEnd()
        if self.vec is not None:
            oprot.writeFieldBegin('vec', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.vec))
            for kiter106, viter107 in self.vec.items():
                oprot.writeString(kiter106.encode('utf-8') if sys.version_info[0] == 2 else kiter106)
                oprot.writeString(viter107.encode('utf-8') if sys.version_info[0] == 2 else viter107)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(batchEncryptWithFlagAndBase64_args)
batchEncryptWithFlagAndBase64_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'flag', 'UTF8', None, ),  # 1
    (2, TType.MAP, 'vec', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 2
)


class batchEncryptWithFlagAndBase64_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ResultListWithFlag()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('batchEncryptWithFlagAndBase64_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(batchEncryptWithFlagAndBase64_result)
batchEncryptWithFlagAndBase64_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ResultListWithFlag, None], None, ),  # 0
)


class batchDecryptWithFlagAndBase64_args(object):
    """
    Attributes:
     - flag
     - vec
    """


    def __init__(self, flag=None, vec=None,):
        self.flag = flag
        self.vec = vec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.flag = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.vec = {}
                    (_ktype109, _vtype110, _size108) = iprot.readMapBegin()
                    for _i112 in range(_size108):
                        _key113 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val114 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.vec[_key113] = _val114
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('batchDecryptWithFlagAndBase64_args')
        if self.flag is not None:
            oprot.writeFieldBegin('flag', TType.STRING, 1)
            oprot.writeString(self.flag.encode('utf-8') if sys.version_info[0] == 2 else self.flag)
            oprot.writeFieldEnd()
        if self.vec is not None:
            oprot.writeFieldBegin('vec', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.vec))
            for kiter115, viter116 in self.vec.items():
                oprot.writeString(kiter115.encode('utf-8') if sys.version_info[0] == 2 else kiter115)
                oprot.writeString(viter116.encode('utf-8') if sys.version_info[0] == 2 else viter116)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(batchDecryptWithFlagAndBase64_args)
batchDecryptWithFlagAndBase64_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'flag', 'UTF8', None, ),  # 1
    (2, TType.MAP, 'vec', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 2
)


class batchDecryptWithFlagAndBase64_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ResultListWithFlag()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('batchDecryptWithFlagAndBase64_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(batchDecryptWithFlagAndBase64_result)
batchDecryptWithFlagAndBase64_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ResultListWithFlag, None], None, ),  # 0
)


class encryptUseEcbModel_args(object):
    """
    Attributes:
     - str
    """


    def __init__(self, str=None,):
        self.str = str

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.str = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('encryptUseEcbModel_args')
        if self.str is not None:
            oprot.writeFieldBegin('str', TType.STRING, 1)
            oprot.writeString(self.str.encode('utf-8') if sys.version_info[0] == 2 else self.str)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(encryptUseEcbModel_args)
encryptUseEcbModel_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'str', 'UTF8', None, ),  # 1
)


class encryptUseEcbModel_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ResultStruct()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('encryptUseEcbModel_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(encryptUseEcbModel_result)
encryptUseEcbModel_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ResultStruct, None], None, ),  # 0
)


class decryptUseEcbModel_args(object):
    """
    Attributes:
     - str
    """


    def __init__(self, str=None,):
        self.str = str

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.str = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('decryptUseEcbModel_args')
        if self.str is not None:
            oprot.writeFieldBegin('str', TType.STRING, 1)
            oprot.writeString(self.str.encode('utf-8') if sys.version_info[0] == 2 else self.str)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(decryptUseEcbModel_args)
decryptUseEcbModel_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'str', 'UTF8', None, ),  # 1
)


class decryptUseEcbModel_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ResultStruct()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('decryptUseEcbModel_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(decryptUseEcbModel_result)
decryptUseEcbModel_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ResultStruct, None], None, ),  # 0
)


class batchEncryptUseEcbModel_args(object):
    """
    Attributes:
     - vec
    """


    def __init__(self, vec=None,):
        self.vec = vec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.vec = {}
                    (_ktype118, _vtype119, _size117) = iprot.readMapBegin()
                    for _i121 in range(_size117):
                        _key122 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val123 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.vec[_key122] = _val123
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('batchEncryptUseEcbModel_args')
        if self.vec is not None:
            oprot.writeFieldBegin('vec', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.vec))
            for kiter124, viter125 in self.vec.items():
                oprot.writeString(kiter124.encode('utf-8') if sys.version_info[0] == 2 else kiter124)
                oprot.writeString(viter125.encode('utf-8') if sys.version_info[0] == 2 else viter125)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(batchEncryptUseEcbModel_args)
batchEncryptUseEcbModel_args.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'vec', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 1
)


class batchEncryptUseEcbModel_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype127, _vtype128, _size126) = iprot.readMapBegin()
                    for _i130 in range(_size126):
                        _key131 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val132 = ResultStruct()
                        _val132.read(iprot)
                        self.success[_key131] = _val132
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('batchEncryptUseEcbModel_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
            for kiter133, viter134 in self.success.items():
                oprot.writeString(kiter133.encode('utf-8') if sys.version_info[0] == 2 else kiter133)
                viter134.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(batchEncryptUseEcbModel_result)
batchEncryptUseEcbModel_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRUCT, [ResultStruct, None], False), None, ),  # 0
)


class batchDecryptUseEcbModel_args(object):
    """
    Attributes:
     - vec
    """


    def __init__(self, vec=None,):
        self.vec = vec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.vec = {}
                    (_ktype136, _vtype137, _size135) = iprot.readMapBegin()
                    for _i139 in range(_size135):
                        _key140 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val141 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.vec[_key140] = _val141
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('batchDecryptUseEcbModel_args')
        if self.vec is not None:
            oprot.writeFieldBegin('vec', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.vec))
            for kiter142, viter143 in self.vec.items():
                oprot.writeString(kiter142.encode('utf-8') if sys.version_info[0] == 2 else kiter142)
                oprot.writeString(viter143.encode('utf-8') if sys.version_info[0] == 2 else viter143)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(batchDecryptUseEcbModel_args)
batchDecryptUseEcbModel_args.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'vec', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 1
)


class batchDecryptUseEcbModel_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype145, _vtype146, _size144) = iprot.readMapBegin()
                    for _i148 in range(_size144):
                        _key149 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val150 = ResultStruct()
                        _val150.read(iprot)
                        self.success[_key149] = _val150
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('batchDecryptUseEcbModel_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
            for kiter151, viter152 in self.success.items():
                oprot.writeString(kiter151.encode('utf-8') if sys.version_info[0] == 2 else kiter151)
                viter152.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(batchDecryptUseEcbModel_result)
batchDecryptUseEcbModel_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRUCT, [ResultStruct, None], False), None, ),  # 0
)
fix_spec(all_structs)
del all_structs

